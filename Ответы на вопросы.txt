1. Абстрактный класс - класс методы которого в отличии от интерфейса могут быть реалтзованы внутри него, но могут быть и как в интерфейсе пустыми и реализовываться уже в потомках. От абстрактного класса мы не создаем экземпляры, экземпляры создаются от его не абстрактных наследников. Он может содержать абстрактные методы, если класс содержит абстрактные методы он обязае быть абстрактным. Если потомок абстрактного класса не переопределит все абстрактные методы родителя он тоже обязан быть абстрактным.
2. Интерфейс отличается от абстрактного класса тем, что в интерфейсе нельзя реализовать методы, которые в нем содержаться, в абстрактном же классе мы имеем право реализовать методы внутри самого класса.
3.В Java мы можем использовать метод уже созданного объекта используя этот объект внутри другого класса передавая объект метод которого мы хотим использовать в тот класс в котором мы хотим его использовать или создавая объект метод которого мы хотим использовать в нужном нам классе.
Пример:
class CompositionExample {
    public static void main(String[] args) {
        Computer myComputer = new Computer("Acer",
                new Monitor());
    }
    static class Monitor {
        Monitor(){}
        public static void showImage() {
            System.out.println("Показываю картинку");
        }
    }

    static class Computer {
        Computer(String name, Monitor monitor){
            System.out.println(name);
            monitor.showImage();
        }
    }
}

  
4. Динамический полиморфизм - используется при переопределении методов. Статический полиморфизм - используется при перегрузке методов. Оба полиморфизма позволяют написанному нами коду работать с объектами различных типов НО Динамический полиморфизм позволяет объектам родительского класса ссылаться на объект наследника и их методы можно вызывать в процессе исполнения программы, код и какой именно тип объекта будет не известны на момент компеляции, а определяются в процессе выполнения, а статический же полиморфизм это вид в котором точный тип объекта и код который будет с ним исползьвоваться должны быть известны при компиляции и не могут быть условно подставленны JVM во время работы программы.
5. Значение ключевого слова super заключается в том, что при переопределении мы можем с помощью него использовать работу исходного метода класса родителя, метод которого переопределяем в наследнике. То есть с помощью super мы можем получить доступ к методу родительского класса из наследника.